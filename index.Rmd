---
title: "Introduction to multiplex single-cell imaging"
output:
  html_document: 
    code_folding: hide
    toc: true
    toc_float: true
---



```{r, echo = FALSE, message = FALSE}
library(tidyverse)

knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%",
  message = FALSE
)

theme_set(theme_bw() + theme(legend.position = "bottom"))
```




## Slide Deck

<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/6ddf94fabdab43cc97d118c6b1cfb52c" title="BDSI_2024" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>


## Multichannel TIFF Data

Here I briefly discuss loading and visualizing raw TIFF data. Typically I focus on data in tabular form post segmentation (not the raw images), but it's helpful to see what they look like.

### Lung cancer data

The following image is a single ROI from a tissue slice from a patient with non small cell lung carcinoma.Cell and tissue segmentation and cell phenotyping were performed using [inForm](https://www.akoyabio.com/phenoimager/software/inform-tissue-finder/) software. For each image, there are multiple Tiff files output by inForm:


* `lung_component_data.tif`: the multichannel file we are most interested in
* `lung_binary_seg_maps.tif`: 3 channel file with binary segmentation maps
* `lung.tif`: A composite image in RGB format. 


```{r}

# load relevant libraries
library(tidyverse)
library(tiff)
library(EBImage)


# define your specific file path
my_path = "./Data/"

# define file for different .tif files
img = paste0(my_path, "lung_component_data.tif")
segmentation = paste0(my_path, "lung_binary_seg_maps.tif")
composite_tif = paste0(my_path, "lung.tif")
```


### Image stack file


The `component.tif` file contains the multichannel tiff, which is a stack of individual images (one for each marker). Below I define a function to read the image stack file and extract metadata.

```{r}
# this function is from phenoptr package on GitHub
# extracts metadata specific to Vectra3/VectraPolaris images
read_image_stacks <- function(path) {
  stopifnot(file.exists(path), endsWith(path, 'component_data.tif'))

  tif = tiff::readTIFF(path, all=TRUE, info=TRUE)

  # Get the image descriptions and figure out which ones are components
  infos = purrr::map_chr(tif, ~attr(., 'description'))
  images = grepl('FullResolution', infos)

  # Get the image_stack names
  names = stringr::str_match(infos[images], '<Name>(.*)</Name>')[, 2]

  purrr::set_names(tif[images], names)
}

image_stack = read_image_stacks(img)
```

The `image_stack` object is now a list, where each list element is a different marker

```{r}
map(image_stack, dim)
```


I can use the `display()` function from the `EBImage` package to plot an individual channel. Below the DAPI (nucleus) channel is plotted.

```{r}
dapi_channel = t(image_stack$"DAPI (DAPI)")
EBImage::display(dapi_channel, method = "raster")
```

Now we plot the CD3 channel (a protein marker for T-cells).

```{r}
tcell_channel = t(image_stack$"CD3 (Opal 520)")
EBImage::display(tcell_channel, method = "raster")
```


### Segmentation files

This data was collected on a Vectra 3 instrument and segmented using [inForm](https://www.akoyabio.com/phenoimager/software/inform-tissue-finder/) tissue analysis software from Akoya Biosciences. This is proprietary image analysis software that can perform cell and tissue segmentation and cell phenotyping. The segmentation below were performed by that software.

```{r}
# source phenoptr code for loading file and metadata, based on tiff::readTIFF.
source("https://raw.githubusercontent.com/akoyabio/phenoptr/main/R/read_maps.R")

segmentations = read_maps(segmentation)
names(segmentations)
```

Nucleus segmentation

```{r}
nucleus = segmentations[['Membrane']]
plot(as.raster(nucleus, max = max(nucleus)))
```


Nucleus segmentation

```{r}
nucleus = segmentations[['Nucleus']]
plot(as.raster(nucleus, max = max(nucleus)))
```

### Composite file

```{r}
# source phenoptr code for loading file and metadata, based on tiff::readTIFF.
source("https://raw.githubusercontent.com/akoyabio/phenoptr/main/R/read_composites.R")

composite = read_composites(composite_tif)
```

```{r}
composite = as.raster(composite[[1]])
plot(composite)
```


```{r}
rm(dapi_channel, image_stack, nucleus,segmentation, tissue, composite, dapi, segmentations, composite_tif, read_maps, read_composites)
```

## VectraPolarisData


The [VectraPolarisData](https://bioconductor.org/packages/release/data/experiment/html/VectraPolarisData.html) [ExperimentHub](http://bioconductor.org/packages/release/bioc/html/ExperimentHub.html) package provides two large multiplex immunofluorescence datasets collected using Akoya Biosciences Vectra 3 and Vectra Polaris platforms. Image preprocessing (cell segmentation and phenotyping) was performed using [inForm](https://www.akoyabio.com/phenoimager/software/inform-tissue-finder/) software. Data are provided as objects of class [SpatialExperiment](https://bioconductor.org/packages/release/bioc/html/SpatialExperiment.html).

```{r, message = FALSE}
# load libraries
library(tidyverse)
```

### Install and load data

The data is publicly available on Bioconductor as the package `VectraPolarisData`. You can install the package from Bioconductor here:

```{r, eval = FALSE, echo = TRUE, message = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
     install.packages("BiocManager")
}

BiocManager::install("VectraPolarisData")

```



### Ovarian cancer data 

Load the high grade serous ovarian cancer data. This dataset has been segmented and phenotyped, and has one image per patient.
I will be working with a form of this data that has already been preprocessed into a tidy dataframe.

```{r}
# load processed ovarian cancer data
load(url("https://github.com/julia-wrobel/MI_tutorial/raw/main/Data/ovarian.RDA"))
```

The resulting dataframe, `ovarian_df`, contains information on marker intensities, cell X and Y position, cell phenotypes, and patient-level characteristics.


```{r, collapse=FALSE}
ovarian_df %>%
  select(contains("id"),tissue_category, cd8, phenotype_cd68, x, y, everything()) %>%
  as_tibble() 
```


Below we plot the cells for a single subject. In this dataset there is one image for each subject, and the image comes from a tumor microarray (TMA).

```{r}

set.seed(7332)
id = sample(ovarian_df$sample_id, 1)

ovarian_df %>%
  filter(sample_id == id) %>%
  ggplot(aes(x, y)) +
  geom_point(aes(color = tissue_category), size = 0.2)


```


```{r}
ovarian_df %>%
  filter(sample_id == id) %>%
  mutate(phenotype_cd68 = ifelse(phenotype_cd68 == "CD68+", "CD68+", "CD68-")) %>%
  ggplot(aes(x, y)) +
  geom_point(aes(color = phenotype_cd68), alpha = 0.8, size = 0.7)

```




### Lung data

Load the non small cell lung carcinoma data and inspect the `SpatialExperiment` object. This dataset has 3-4 images per patient, representing different regions of interest (ROIs) from a tissue slice. In this dataset, each patient was imaged on a separate slide.

```{r}
# load processed ovarian cancer data
load(url("https://github.com/julia-wrobel/MI_tutorial/raw/main/Data/lung.RDA"))
```


```{r}
set.seed(23423)
id = sample(lung_df$patient_id, 1)

lung_df %>%
  filter(patient_id == id) %>%
  ggplot(aes(x, y)) +
  geom_point(aes(color = tissue_category), size = 0.3) +
  facet_wrap(~image_id)

```

```{r, echo = FALSE}
rm(lung_df)
```




## Spatial Analysis using spatstat package



The `spatstat` package in `R` has great resources for analyzing spatial point patterns. Let's use the image above to do some exploratory analysis with spatstat.

We will do spatial analysis on the distribution of B-cells and macrophages, so we subset to only these cell types, and create a `phenotype` variable that designates whether a cell is a B cell or a macrophage. Then we create a `ppp` object, which is what the `spatstat` package uses for storage and analysis of point pattern data.


```{r}
subj_df = filter(ovarian_df, sample_id == 7) 

library(spatstat)

subj_df = subj_df %>%
  # create a phenotype variable that is B-cell, macrophage, or other
  mutate(phenotype = case_when(
    phenotype_cd68 == "CD68+" ~ "macrophage",
    phenotype_cd19 == "CD19+" ~ "B-cell",
    TRUE ~ "other"
  )) %>%
  filter(phenotype != "other") %>%
  select(x,y, immune, tissue_category, phenotype)

# first define window of observation for your image
w = convexhull.xy(subj_df$x,subj_df$y)

# create ppp object as multitype point pattern
# need to factor the marks variable for ppp object to be treated as a multitype point pattern
ovarian_pp = ppp(subj_df$x,subj_df$y, window = w,
                 marks = factor(subj_df$phenotype))
```


### Univariate Ripley's  K


First we calculate Ripley's K for B cells.  


```{r}
k_bcell =  Kest(subset(ovarian_pp, marks == "B-cell"), correction = "isotropic")
```

We can plot this `k_bcell` object using `spatstat` to visualize the estimated K ($\hat{K}^{iso}$) compared to the K under CSR ($K^{pois}$).

```{r}
plot(k_bcell)
```

Now visualize the K-function for macrophages in this image:

```{r}
k_mac =  Kest(subset(ovarian_pp, marks == "macrophage"), 
              correction = "isotropic")
plot(k_mac)
```

It appears that there is some degree of clustering for both B-cells and macrophages in this image. Are these statistically significant?

We can test this using the `envelope` function, which performs Monte Carlo simulations of the K function under CSR. Plot below shows pointwise envelope for B-cell K-function. Pointwise means that these are performed separately for each value of *r*. Can only be interpreted if a specific value of *r* is chosen in advance.

```{r}

e_test = envelope(subset(ovarian_pp, marks == "B-cell"), 
               Kest, correction = "isotropic", global = TRUE)

plot(e_test)

```

Points outside the envelope indicate significant departure from CSR. Note that this could be due to inhomogeneity in the distribution of cells, or due to clustering. See `spatstat::Kinhom` function for a test that takes into account inhomogeneity. See `spatstat::Lest` function to compute the L-function.


### Bivariate Ripley's  K

The bivariate K function measures whether the spatial distribution of 2 cell types is independent. Deviation from the $K^{pois}$ line suggests a spatial relationship between the B-cells and macrophages in the image.

```{r}
k_biv = Kcross(ovarian_pp, "B-cell", "macrophage", correction = "isotropic")

plot(k_biv)
```


## Additional Reading

Below are original citations for the two example datasets I will be working with in this tutorial.

* [Paper for ovarian cancer data](https://aacrjournals.org/mcr/article/19/12/1973/675069/The-Spatial-Context-of-Tumor-Infiltrating-Immune)
* [Paper for non-small cell lung carcinoma data](https://pubmed.ncbi.nlm.nih.gov/34048945/)
* [spatstat JSS article](https://www.jstatsoft.org/article/view/v012i06)
* [Vignette for VectraPolarisData](https://bioconductor.org/packages/release/data/experiment/vignettes/VectraPolarisData/inst/doc/VectraPolarisData.html)
* [textbook chapter, Wrobel and Vandekar](http://juliawrobel.com/Downloads/mIF_chapter.pdf)
* [Challenges and Opportunities in the Statistical Analysis of Multiplex Immunofluorescence Data](https://www.mdpi.com/2072-6694/13/12/3031)
* [Catching up with multiplexed tissue imaging](https://www.nature.com/articles/s41592-022-01428-z) 
* [The emerging landscape of spatial profiling technologies](https://www.nature.com/articles/s41576-022-00515-3)